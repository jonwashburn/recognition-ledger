#!/usr/bin/env python3
"""
lnal_CMB_fit.py  ─  Deliverable B
────────────────────────────────────────────────────────────────────────────
Cosmic-scale gravity test for the LNAL parameter chain.

Goal
────
Vary a single parameter λ_eff (recognition hop length) around its nominal
value (~60 µm) and show that the running-G kernel plus information field
reproduces the observed effective matter fraction Ω_m,obs ≈ 0.31 while
setting the true cold-dark-matter density to zero.

Strategy
────────
1.  Use the CLASS Boltzmann code via its Python wrapper *classy*.
2.  Keep the baryon density fixed to the Planck 2018 best-fit value
      Ω_b h² = 0.0224.
3.  Set Ω_cdm = 0 and neutrino mass to 0.06 eV (minimal mass).
4.  Implement a scale-dependent effective Newton constant

        G_eff(k) = G_Newton · (λ_eff k)^β , β = −(φ − 1)/φ⁵ ≃ −0.055728

    where k is the Fourier mode [1/Mpc] and λ_eff is varied.
    CLASS offers a generic modified-gravity interface via *mg_flag = 1* and
    user-supplied *G_eff* functions (see CLASS v3.2 manual).  We implement a
    tiny wrapper library `lnal_mg.py` that CLASS can import at runtime.
5.  For each λ_eff on a small grid perform a fast χ² evaluation against the
    Planck 2018 TT + TE + EE likelihood (if installed) **or** compute the
    derived effective matter density through the growth function as a proxy
    when Planck likelihoods are unavailable.
6.  Report χ² and derived Ω_m,eff.  Success criteria:

        χ² − χ²_ΛCDM < 30  and  Ω_m,eff ∈ [0.29, 0.33]

Dependencies
────────────
• classy (CLASS ≥ v3.2)
• numpy, scipy, tqdm, matplotlib (for diagnostics)
• [optional] *planck-likelihood* package if the user wants to compute
  full Planck χ² (otherwise a proxy growth-function test is used).

Installation hints (run once):
    pip install classy==3.2.0 numpy scipy tqdm matplotlib
    # optional – requires Planck data licence
    pip install planck-likelihood

Usage examples
──────────────
    # Quick grid scan (no Planck likelihoods)
    python lnal_CMB_fit.py  --quick

    # Full MCMC with Planck likelihoods
    python lnal_CMB_fit.py  --mcmc  --nwalkers 32  --nsamples 5000
"""

from __future__ import annotations

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Dict, Any, List

import numpy as np
from tqdm import tqdm

try:
    from classy import Class
except ImportError as err:
    sys.exit(
        "ERROR: classy (CLASS Python wrapper) is required.\n"
        "Install with  pip install classy==3.2.0  and rerun.\n"
    )

# -------------------------------------------------------
# Fundamental constants & RS parameter chain (from Axioms)
# -------------------------------------------------------
phi = (1 + 5 ** 0.5) / 2  # golden ratio
beta = -(phi - 1) / phi ** 5  # ≈ −0.055728, running-G exponent

LAM_EFF_NOMINAL = 60e-6  # 60 µm  (road-map central value)
LAM_EFF_GRID = np.arange(56e-6, 65e-6, 2e-6)  # ±4 µm grid (step 2 µm)

# Standard cosmological parameters (ΛCDM best-fits except CDM→0)
H0 = 67.4
OMEGA_B_H2 = 0.0224
TCMB = 2.7255
N_UV = 3.046
M_NU = 0.06  # minimal mass (eV)

# CLASS modified-gravity interface -----------------------
# We generate a tiny module file that CLASS will import to evaluate G_eff(k).
# The file is dropped in the working dir the first time this script is run.
MG_MODULE_PATH = Path("lnal_mg.py")
MG_TEMPLATE = f'''# Auto-generated by lnal_CMB_fit.py
from math import pow

def G_eff(a, k):
    """Effective Newton constant modification for LNAL gravity."""
    # a : scale factor (dimensionless)
    # k : Fourier mode in [1/Mpc]
    LAM_EFF = {{LAM_EFF_SUB}}  # [Mpc] (patched at runtime)
    beta = {beta:.8f}
    return pow(LAM_EFF * k, beta)
'''


def ensure_mg_module(lambda_eff_m: float) -> None:
    """Create the mg module for the supplied λ_eff in metres."""
    lam_eff_mpc = lambda_eff_m / (3.085677581e22)  # m → Mpc
    code = MG_TEMPLATE.replace("{LAM_EFF_SUB}", f"{lam_eff_mpc:.6e}")
    MG_MODULE_PATH.write_text(code)


# -------------------------------------------------------
# Helper functions
# -------------------------------------------------------

def class_params(lambda_eff: float) -> Dict[str, Any]:
    """Return CLASS parameter dictionary for a given λ_eff (metres)."""
    ensure_mg_module(lambda_eff)
    params = {
        # Background
        "h": H0 / 100.0,
        "T_cmb": TCMB,
        "N_ur": N_UV,
        "Omega_cdm": 0.0,
        "Omega_b": OMEGA_B_H2 / (H0 / 100.0) ** 2,
        "m_ncdm": M_NU,
        "N_ncdm": 1,
        "n_s": 0.965,
        "A_s": 2.1e-9,
        "YHe": 0.245,
        # MG flags
        "mg_flag": 1,
        "gravity_gradient_threshold": 0,  # make sure MG always used
        "G_eff": "lnal_mg.G_eff",  # module.function path
        "output": "mPk Cls",
        "l_max_scalars": 2500,
        "P_k_max_1/Mpc": 5.0,
    }
    return params


def compute_cls(lambda_eff: float) -> Dict[str, Any]:
    """Run CLASS and return power spectra & derived parameters."""
    cosmo = Class()
    cosmo.set(class_params(lambda_eff))
    cosmo.compute()
    cls = cosmo.lensed_cl(2500)
    pk = cosmo.get_pk(k=np.logspace(-4, 1, 200), z=[0])[0]
    omega_m_eff = cosmo.omega_m()
    chi2_proxy = chi2_growth_proxy(cosmo)  # lightweight χ² approximation
    cosmo.struct_cleanup()
    cosmo.empty()
    return {
        "lambda_eff": lambda_eff,
        "omega_m_eff": omega_m_eff,
        "chi2_proxy": chi2_proxy,
        "cls_sample": cls[100:200:10, 0].tolist(),  # sample TT for quick plot
        "pk_0": pk.tolist(),
    }


def chi2_growth_proxy(cosmo: Class) -> float:
    """Cheap χ² proxy: compare σ8 and fσ8 to Planck-derived targets."""
    sigma8 = cosmo.sigma8()
    fs8 = cosmo.scale_independent_growth_factor_f(0) * sigma8
    # Planck 2018: σ8≈0.811±0.006, fσ8≈0.48±0.05 (RSD)
    chi2 = ((sigma8 - 0.811) / 0.006) ** 2 + ((fs8 - 0.48) / 0.05) ** 2
    return chi2


# -------------------------------------------------------
# Main routines
# -------------------------------------------------------

def quick_grid() -> None:
    """Evaluate χ² proxy and Ω_m,eff on a small grid of λ_eff values."""
    results: List[Dict[str, Any]] = []
    for lam in tqdm(LAM_EFF_GRID, desc="Grid scan"):
        res = compute_cls(lam)
        results.append(res)
        print(
            f"λ_eff = {lam*1e6:.1f} µm  →  Ω_m,eff = {res['omega_m_eff']:.3f}  "
            f"Δχ²_proxy = {res['chi2_proxy']:.2f}"
        )
    # Save to JSON
    with open("lnal_CMB_grid_results.json", "w") as fh:
        json.dump(results, fh, indent=2)
    print("Grid results saved to lnal_CMB_grid_results.json")


# Placeholder for full MCMC (not yet implemented)
# -------------------------------------------------

def mcmc_run(nwalkers: int, nsamples: int) -> None:
    print("Full MCMC is not yet implemented in this prototype.\n" "Use --quick for now.")


# -------------------------------------------------------
# Command-line interface
# -------------------------------------------------------

def main() -> None:
    ap = argparse.ArgumentParser(description="LNAL cosmic gravity test (Deliverable B)")
    ap.add_argument("--quick", action="store_true", help="Run quick grid scan only")
    ap.add_argument("--mcmc", action="store_true", help="Run MCMC fit (requires planck likelihoods)")
    ap.add_argument("--nwalkers", type=int, default=32)
    ap.add_argument("--nsamples", type=int, default=5000)
    args = ap.parse_args()

    if args.quick or not args.mcmc:
        quick_grid()
    else:
        mcmc_run(args.nwalkers, args.nsamples)


if __name__ == "__main__":
    main() 